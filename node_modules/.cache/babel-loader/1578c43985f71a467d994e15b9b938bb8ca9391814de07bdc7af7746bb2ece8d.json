{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n0 && (module.exports = {\n  getNamedMiddlewareRegex: null,\n  getNamedRouteRegex: null,\n  getRouteRegex: null,\n  parseParameter: null\n});\nfunction _export(target, all) {\n  for (var name in all) Object.defineProperty(target, name, {\n    enumerable: true,\n    get: all[name]\n  });\n}\n_export(exports, {\n  getNamedMiddlewareRegex: function () {\n    return getNamedMiddlewareRegex;\n  },\n  getNamedRouteRegex: function () {\n    return getNamedRouteRegex;\n  },\n  getRouteRegex: function () {\n    return getRouteRegex;\n  },\n  parseParameter: function () {\n    return parseParameter;\n  }\n});\nconst _constants = require(\"../../../../lib/constants\");\nconst _interceptionroutes = require(\"./interception-routes\");\nconst _escaperegexp = require(\"../../escape-regexp\");\nconst _removetrailingslash = require(\"./remove-trailing-slash\");\n/**\n * Regular expression pattern used to match route parameters.\n * Matches both single parameters and parameter groups.\n * Examples:\n *   - `[[...slug]]` matches parameter group with key 'slug', repeat: true, optional: true\n *   - `[...slug]` matches parameter group with key 'slug', repeat: true, optional: false\n *   - `[[foo]]` matches parameter with key 'foo', repeat: false, optional: true\n *   - `[bar]` matches parameter with key 'bar', repeat: false, optional: false\n */\nconst PARAMETER_PATTERN = /^([^[]*)\\[((?:\\[[^\\]]*\\])|[^\\]]+)\\](.*)$/;\nfunction parseParameter(param) {\n  const match = param.match(PARAMETER_PATTERN);\n  if (!match) {\n    return parseMatchedParameter(param);\n  }\n  return parseMatchedParameter(match[2]);\n}\n/**\n * Parses a matched parameter from the PARAMETER_PATTERN regex to a data structure that can be used\n * to generate the parametrized route.\n * Examples:\n *   - `[...slug]` -> `{ key: 'slug', repeat: true, optional: true }`\n *   - `...slug` -> `{ key: 'slug', repeat: true, optional: false }`\n *   - `[foo]` -> `{ key: 'foo', repeat: false, optional: true }`\n *   - `bar` -> `{ key: 'bar', repeat: false, optional: false }`\n * @param param - The matched parameter to parse.\n * @returns The parsed parameter as a data structure.\n */\nfunction parseMatchedParameter(param) {\n  const optional = param.startsWith('[') && param.endsWith(']');\n  if (optional) {\n    param = param.slice(1, -1);\n  }\n  const repeat = param.startsWith('...');\n  if (repeat) {\n    param = param.slice(3);\n  }\n  return {\n    key: param,\n    repeat,\n    optional\n  };\n}\nfunction getParametrizedRoute(route, includeSuffix, includePrefix) {\n  const groups = {};\n  let groupIndex = 1;\n  const segments = [];\n  for (const segment of (0, _removetrailingslash.removeTrailingSlash)(route).slice(1).split('/')) {\n    const markerMatch = _interceptionroutes.INTERCEPTION_ROUTE_MARKERS.find(m => segment.startsWith(m));\n    const paramMatches = segment.match(PARAMETER_PATTERN) // Check for parameters\n    ;\n    if (markerMatch && paramMatches && paramMatches[2]) {\n      const {\n        key,\n        optional,\n        repeat\n      } = parseMatchedParameter(paramMatches[2]);\n      groups[key] = {\n        pos: groupIndex++,\n        repeat,\n        optional\n      };\n      segments.push(\"/\" + (0, _escaperegexp.escapeStringRegexp)(markerMatch) + \"([^/]+?)\");\n    } else if (paramMatches && paramMatches[2]) {\n      const {\n        key,\n        repeat,\n        optional\n      } = parseMatchedParameter(paramMatches[2]);\n      groups[key] = {\n        pos: groupIndex++,\n        repeat,\n        optional\n      };\n      if (includePrefix && paramMatches[1]) {\n        segments.push(\"/\" + (0, _escaperegexp.escapeStringRegexp)(paramMatches[1]));\n      }\n      let s = repeat ? optional ? '(?:/(.+?))?' : '/(.+?)' : '/([^/]+?)';\n      // Remove the leading slash if includePrefix already added it.\n      if (includePrefix && paramMatches[1]) {\n        s = s.substring(1);\n      }\n      segments.push(s);\n    } else {\n      segments.push(\"/\" + (0, _escaperegexp.escapeStringRegexp)(segment));\n    }\n    // If there's a suffix, add it to the segments if it's enabled.\n    if (includeSuffix && paramMatches && paramMatches[3]) {\n      segments.push((0, _escaperegexp.escapeStringRegexp)(paramMatches[3]));\n    }\n  }\n  return {\n    parameterizedRoute: segments.join(''),\n    groups\n  };\n}\nfunction getRouteRegex(normalizedRoute, param) {\n  let {\n    includeSuffix = false,\n    includePrefix = false,\n    excludeOptionalTrailingSlash = false\n  } = param === void 0 ? {} : param;\n  const {\n    parameterizedRoute,\n    groups\n  } = getParametrizedRoute(normalizedRoute, includeSuffix, includePrefix);\n  let re = parameterizedRoute;\n  if (!excludeOptionalTrailingSlash) {\n    re += '(?:/)?';\n  }\n  return {\n    re: new RegExp(\"^\" + re + \"$\"),\n    groups: groups\n  };\n}\n/**\n * Builds a function to generate a minimal routeKey using only a-z and minimal\n * number of characters.\n */\nfunction buildGetSafeRouteKey() {\n  let i = 0;\n  return () => {\n    let routeKey = '';\n    let j = ++i;\n    while (j > 0) {\n      routeKey += String.fromCharCode(97 + (j - 1) % 26);\n      j = Math.floor((j - 1) / 26);\n    }\n    return routeKey;\n  };\n}\nfunction getSafeKeyFromSegment(param) {\n  let {\n    interceptionMarker,\n    getSafeRouteKey,\n    segment,\n    routeKeys,\n    keyPrefix,\n    backreferenceDuplicateKeys\n  } = param;\n  const {\n    key,\n    optional,\n    repeat\n  } = parseMatchedParameter(segment);\n  // replace any non-word characters since they can break\n  // the named regex\n  let cleanedKey = key.replace(/\\W/g, '');\n  if (keyPrefix) {\n    cleanedKey = \"\" + keyPrefix + cleanedKey;\n  }\n  let invalidKey = false;\n  // check if the key is still invalid and fallback to using a known\n  // safe key\n  if (cleanedKey.length === 0 || cleanedKey.length > 30) {\n    invalidKey = true;\n  }\n  if (!isNaN(parseInt(cleanedKey.slice(0, 1)))) {\n    invalidKey = true;\n  }\n  if (invalidKey) {\n    cleanedKey = getSafeRouteKey();\n  }\n  const duplicateKey = cleanedKey in routeKeys;\n  if (keyPrefix) {\n    routeKeys[cleanedKey] = \"\" + keyPrefix + key;\n  } else {\n    routeKeys[cleanedKey] = key;\n  }\n  // if the segment has an interception marker, make sure that's part of the regex pattern\n  // this is to ensure that the route with the interception marker doesn't incorrectly match\n  // the non-intercepted route (ie /app/(.)[username] should not match /app/[username])\n  const interceptionPrefix = interceptionMarker ? (0, _escaperegexp.escapeStringRegexp)(interceptionMarker) : '';\n  let pattern;\n  if (duplicateKey && backreferenceDuplicateKeys) {\n    // Use a backreference to the key to ensure that the key is the same value\n    // in each of the placeholders.\n    pattern = \"\\\\k<\" + cleanedKey + \">\";\n  } else if (repeat) {\n    pattern = \"(?<\" + cleanedKey + \">.+?)\";\n  } else {\n    pattern = \"(?<\" + cleanedKey + \">[^/]+?)\";\n  }\n  return optional ? \"(?:/\" + interceptionPrefix + pattern + \")?\" : \"/\" + interceptionPrefix + pattern;\n}\nfunction getNamedParametrizedRoute(route, prefixRouteKeys, includeSuffix, includePrefix, backreferenceDuplicateKeys) {\n  const getSafeRouteKey = buildGetSafeRouteKey();\n  const routeKeys = {};\n  const segments = [];\n  for (const segment of (0, _removetrailingslash.removeTrailingSlash)(route).slice(1).split('/')) {\n    const hasInterceptionMarker = _interceptionroutes.INTERCEPTION_ROUTE_MARKERS.some(m => segment.startsWith(m));\n    const paramMatches = segment.match(PARAMETER_PATTERN) // Check for parameters\n    ;\n    if (hasInterceptionMarker && paramMatches && paramMatches[2]) {\n      // If there's an interception marker, add it to the segments.\n      segments.push(getSafeKeyFromSegment({\n        getSafeRouteKey,\n        interceptionMarker: paramMatches[1],\n        segment: paramMatches[2],\n        routeKeys,\n        keyPrefix: prefixRouteKeys ? _constants.NEXT_INTERCEPTION_MARKER_PREFIX : undefined,\n        backreferenceDuplicateKeys\n      }));\n    } else if (paramMatches && paramMatches[2]) {\n      // If there's a prefix, add it to the segments if it's enabled.\n      if (includePrefix && paramMatches[1]) {\n        segments.push(\"/\" + (0, _escaperegexp.escapeStringRegexp)(paramMatches[1]));\n      }\n      let s = getSafeKeyFromSegment({\n        getSafeRouteKey,\n        segment: paramMatches[2],\n        routeKeys,\n        keyPrefix: prefixRouteKeys ? _constants.NEXT_QUERY_PARAM_PREFIX : undefined,\n        backreferenceDuplicateKeys\n      });\n      // Remove the leading slash if includePrefix already added it.\n      if (includePrefix && paramMatches[1]) {\n        s = s.substring(1);\n      }\n      segments.push(s);\n    } else {\n      segments.push(\"/\" + (0, _escaperegexp.escapeStringRegexp)(segment));\n    }\n    // If there's a suffix, add it to the segments if it's enabled.\n    if (includeSuffix && paramMatches && paramMatches[3]) {\n      segments.push((0, _escaperegexp.escapeStringRegexp)(paramMatches[3]));\n    }\n  }\n  return {\n    namedParameterizedRoute: segments.join(''),\n    routeKeys\n  };\n}\nfunction getNamedRouteRegex(normalizedRoute, options) {\n  var _options_includeSuffix, _options_includePrefix, _options_backreferenceDuplicateKeys;\n  const result = getNamedParametrizedRoute(normalizedRoute, options.prefixRouteKeys, (_options_includeSuffix = options.includeSuffix) != null ? _options_includeSuffix : false, (_options_includePrefix = options.includePrefix) != null ? _options_includePrefix : false, (_options_backreferenceDuplicateKeys = options.backreferenceDuplicateKeys) != null ? _options_backreferenceDuplicateKeys : false);\n  let namedRegex = result.namedParameterizedRoute;\n  if (!options.excludeOptionalTrailingSlash) {\n    namedRegex += '(?:/)?';\n  }\n  return {\n    ...getRouteRegex(normalizedRoute, options),\n    namedRegex: \"^\" + namedRegex + \"$\",\n    routeKeys: result.routeKeys\n  };\n}\nfunction getNamedMiddlewareRegex(normalizedRoute, options) {\n  const {\n    parameterizedRoute\n  } = getParametrizedRoute(normalizedRoute, false, false);\n  const {\n    catchAll = true\n  } = options;\n  if (parameterizedRoute === '/') {\n    let catchAllRegex = catchAll ? '.*' : '';\n    return {\n      namedRegex: \"^/\" + catchAllRegex + \"$\"\n    };\n  }\n  const {\n    namedParameterizedRoute\n  } = getNamedParametrizedRoute(normalizedRoute, false, false, false, false);\n  let catchAllGroupedRegex = catchAll ? '(?:(/.*)?)' : '';\n  return {\n    namedRegex: \"^\" + namedParameterizedRoute + catchAllGroupedRegex + \"$\"\n  };\n}","map":{"version":3,"names":["getNamedMiddlewareRegex","getNamedRouteRegex","getRouteRegex","parseParameter","PARAMETER_PATTERN","param","match","parseMatchedParameter","optional","startsWith","endsWith","slice","repeat","key","getParametrizedRoute","route","includeSuffix","includePrefix","groups","groupIndex","segments","segment","_removetrailingslash","removeTrailingSlash","split","markerMatch","_interceptionroutes","INTERCEPTION_ROUTE_MARKERS","find","m","paramMatches","pos","push","_escaperegexp","escapeStringRegexp","s","substring","parameterizedRoute","join","normalizedRoute","excludeOptionalTrailingSlash","re","RegExp","buildGetSafeRouteKey","i","routeKey","j","String","fromCharCode","Math","floor","getSafeKeyFromSegment","interceptionMarker","getSafeRouteKey","routeKeys","keyPrefix","backreferenceDuplicateKeys","cleanedKey","replace","invalidKey","length","isNaN","parseInt","duplicateKey","interceptionPrefix","pattern","getNamedParametrizedRoute","prefixRouteKeys","hasInterceptionMarker","some","_constants","NEXT_INTERCEPTION_MARKER_PREFIX","undefined","NEXT_QUERY_PARAM_PREFIX","namedParameterizedRoute","options","_options_includeSuffix","_options_includePrefix","_options_backreferenceDuplicateKeys","result","namedRegex","catchAll","catchAllRegex","catchAllGroupedRegex"],"sources":["C:\\Users\\Subham Kumar\\Desktop\\node_modules\\next\\src\\shared\\lib\\router\\utils\\route-regex.ts"],"sourcesContent":["import {\n  NEXT_INTERCEPTION_MARKER_PREFIX,\n  NEXT_QUERY_PARAM_PREFIX,\n} from '../../../../lib/constants'\nimport { INTERCEPTION_ROUTE_MARKERS } from './interception-routes'\nimport { escapeStringRegexp } from '../../escape-regexp'\nimport { removeTrailingSlash } from './remove-trailing-slash'\n\nexport interface Group {\n  pos: number\n  repeat: boolean\n  optional: boolean\n}\n\nexport interface RouteRegex {\n  groups: { [groupName: string]: Group }\n  re: RegExp\n}\n\ntype GetNamedRouteRegexOptions = {\n  /**\n   * Whether to prefix the route keys with the NEXT_INTERCEPTION_MARKER_PREFIX\n   * or NEXT_QUERY_PARAM_PREFIX. This is only relevant when creating the\n   * routes-manifest during the build.\n   */\n  prefixRouteKeys: boolean\n\n  /**\n   * Whether to include the suffix in the route regex. This means that when you\n   * have something like `/[...slug].json` the `.json` part will be included\n   * in the regex, yielding `/(.*).json` as the regex.\n   */\n  includeSuffix?: boolean\n\n  /**\n   * Whether to include the prefix in the route regex. This means that when you\n   * have something like `/[...slug].json` the `/` part will be included\n   * in the regex, yielding `^/(.*).json$` as the regex.\n   *\n   * Note that interception markers will already be included without the need\n   */\n  includePrefix?: boolean\n\n  /**\n   * Whether to exclude the optional trailing slash from the route regex.\n   */\n  excludeOptionalTrailingSlash?: boolean\n\n  /**\n   * Whether to backtrack duplicate keys. This is only relevant when creating\n   * the routes-manifest during the build.\n   */\n  backreferenceDuplicateKeys?: boolean\n}\n\ntype GetRouteRegexOptions = {\n  /**\n   * Whether to include extra parts in the route regex. This means that when you\n   * have something like `/[...slug].json` the `.json` part will be included\n   * in the regex, yielding `/(.*).json` as the regex.\n   */\n  includeSuffix?: boolean\n\n  /**\n   * Whether to include the prefix in the route regex. This means that when you\n   * have something like `/[...slug].json` the `/` part will be included\n   * in the regex, yielding `^/(.*).json$` as the regex.\n   *\n   * Note that interception markers will already be included without the need\n   * of adding this option.\n   */\n  includePrefix?: boolean\n\n  /**\n   * Whether to exclude the optional trailing slash from the route regex.\n   */\n  excludeOptionalTrailingSlash?: boolean\n}\n\n/**\n * Regular expression pattern used to match route parameters.\n * Matches both single parameters and parameter groups.\n * Examples:\n *   - `[[...slug]]` matches parameter group with key 'slug', repeat: true, optional: true\n *   - `[...slug]` matches parameter group with key 'slug', repeat: true, optional: false\n *   - `[[foo]]` matches parameter with key 'foo', repeat: false, optional: true\n *   - `[bar]` matches parameter with key 'bar', repeat: false, optional: false\n */\nconst PARAMETER_PATTERN = /^([^[]*)\\[((?:\\[[^\\]]*\\])|[^\\]]+)\\](.*)$/\n\n/**\n * Parses a given parameter from a route to a data structure that can be used\n * to generate the parametrized route.\n * Examples:\n *   - `[[...slug]]` -> `{ key: 'slug', repeat: true, optional: true }`\n *   - `[...slug]` -> `{ key: 'slug', repeat: true, optional: false }`\n *   - `[[foo]]` -> `{ key: 'foo', repeat: false, optional: true }`\n *   - `[bar]` -> `{ key: 'bar', repeat: false, optional: false }`\n *   - `fizz` -> `{ key: 'fizz', repeat: false, optional: false }`\n * @param param - The parameter to parse.\n * @returns The parsed parameter as a data structure.\n */\nexport function parseParameter(param: string) {\n  const match = param.match(PARAMETER_PATTERN)\n\n  if (!match) {\n    return parseMatchedParameter(param)\n  }\n\n  return parseMatchedParameter(match[2])\n}\n\n/**\n * Parses a matched parameter from the PARAMETER_PATTERN regex to a data structure that can be used\n * to generate the parametrized route.\n * Examples:\n *   - `[...slug]` -> `{ key: 'slug', repeat: true, optional: true }`\n *   - `...slug` -> `{ key: 'slug', repeat: true, optional: false }`\n *   - `[foo]` -> `{ key: 'foo', repeat: false, optional: true }`\n *   - `bar` -> `{ key: 'bar', repeat: false, optional: false }`\n * @param param - The matched parameter to parse.\n * @returns The parsed parameter as a data structure.\n */\nfunction parseMatchedParameter(param: string) {\n  const optional = param.startsWith('[') && param.endsWith(']')\n  if (optional) {\n    param = param.slice(1, -1)\n  }\n  const repeat = param.startsWith('...')\n  if (repeat) {\n    param = param.slice(3)\n  }\n  return { key: param, repeat, optional }\n}\n\nfunction getParametrizedRoute(\n  route: string,\n  includeSuffix: boolean,\n  includePrefix: boolean\n) {\n  const groups: { [groupName: string]: Group } = {}\n  let groupIndex = 1\n\n  const segments: string[] = []\n  for (const segment of removeTrailingSlash(route).slice(1).split('/')) {\n    const markerMatch = INTERCEPTION_ROUTE_MARKERS.find((m) =>\n      segment.startsWith(m)\n    )\n    const paramMatches = segment.match(PARAMETER_PATTERN) // Check for parameters\n\n    if (markerMatch && paramMatches && paramMatches[2]) {\n      const { key, optional, repeat } = parseMatchedParameter(paramMatches[2])\n      groups[key] = { pos: groupIndex++, repeat, optional }\n      segments.push(`/${escapeStringRegexp(markerMatch)}([^/]+?)`)\n    } else if (paramMatches && paramMatches[2]) {\n      const { key, repeat, optional } = parseMatchedParameter(paramMatches[2])\n      groups[key] = { pos: groupIndex++, repeat, optional }\n\n      if (includePrefix && paramMatches[1]) {\n        segments.push(`/${escapeStringRegexp(paramMatches[1])}`)\n      }\n\n      let s = repeat ? (optional ? '(?:/(.+?))?' : '/(.+?)') : '/([^/]+?)'\n\n      // Remove the leading slash if includePrefix already added it.\n      if (includePrefix && paramMatches[1]) {\n        s = s.substring(1)\n      }\n\n      segments.push(s)\n    } else {\n      segments.push(`/${escapeStringRegexp(segment)}`)\n    }\n\n    // If there's a suffix, add it to the segments if it's enabled.\n    if (includeSuffix && paramMatches && paramMatches[3]) {\n      segments.push(escapeStringRegexp(paramMatches[3]))\n    }\n  }\n\n  return {\n    parameterizedRoute: segments.join(''),\n    groups,\n  }\n}\n\n/**\n * From a normalized route this function generates a regular expression and\n * a corresponding groups object intended to be used to store matching groups\n * from the regular expression.\n */\nexport function getRouteRegex(\n  normalizedRoute: string,\n  {\n    includeSuffix = false,\n    includePrefix = false,\n    excludeOptionalTrailingSlash = false,\n  }: GetRouteRegexOptions = {}\n): RouteRegex {\n  const { parameterizedRoute, groups } = getParametrizedRoute(\n    normalizedRoute,\n    includeSuffix,\n    includePrefix\n  )\n\n  let re = parameterizedRoute\n  if (!excludeOptionalTrailingSlash) {\n    re += '(?:/)?'\n  }\n\n  return {\n    re: new RegExp(`^${re}$`),\n    groups: groups,\n  }\n}\n\n/**\n * Builds a function to generate a minimal routeKey using only a-z and minimal\n * number of characters.\n */\nfunction buildGetSafeRouteKey() {\n  let i = 0\n\n  return () => {\n    let routeKey = ''\n    let j = ++i\n    while (j > 0) {\n      routeKey += String.fromCharCode(97 + ((j - 1) % 26))\n      j = Math.floor((j - 1) / 26)\n    }\n    return routeKey\n  }\n}\n\nfunction getSafeKeyFromSegment({\n  interceptionMarker,\n  getSafeRouteKey,\n  segment,\n  routeKeys,\n  keyPrefix,\n  backreferenceDuplicateKeys,\n}: {\n  interceptionMarker?: string\n  getSafeRouteKey: () => string\n  segment: string\n  routeKeys: Record<string, string>\n  keyPrefix?: string\n  backreferenceDuplicateKeys: boolean\n}) {\n  const { key, optional, repeat } = parseMatchedParameter(segment)\n\n  // replace any non-word characters since they can break\n  // the named regex\n  let cleanedKey = key.replace(/\\W/g, '')\n\n  if (keyPrefix) {\n    cleanedKey = `${keyPrefix}${cleanedKey}`\n  }\n  let invalidKey = false\n\n  // check if the key is still invalid and fallback to using a known\n  // safe key\n  if (cleanedKey.length === 0 || cleanedKey.length > 30) {\n    invalidKey = true\n  }\n  if (!isNaN(parseInt(cleanedKey.slice(0, 1)))) {\n    invalidKey = true\n  }\n\n  if (invalidKey) {\n    cleanedKey = getSafeRouteKey()\n  }\n\n  const duplicateKey = cleanedKey in routeKeys\n\n  if (keyPrefix) {\n    routeKeys[cleanedKey] = `${keyPrefix}${key}`\n  } else {\n    routeKeys[cleanedKey] = key\n  }\n\n  // if the segment has an interception marker, make sure that's part of the regex pattern\n  // this is to ensure that the route with the interception marker doesn't incorrectly match\n  // the non-intercepted route (ie /app/(.)[username] should not match /app/[username])\n  const interceptionPrefix = interceptionMarker\n    ? escapeStringRegexp(interceptionMarker)\n    : ''\n\n  let pattern: string\n  if (duplicateKey && backreferenceDuplicateKeys) {\n    // Use a backreference to the key to ensure that the key is the same value\n    // in each of the placeholders.\n    pattern = `\\\\k<${cleanedKey}>`\n  } else if (repeat) {\n    pattern = `(?<${cleanedKey}>.+?)`\n  } else {\n    pattern = `(?<${cleanedKey}>[^/]+?)`\n  }\n\n  return optional\n    ? `(?:/${interceptionPrefix}${pattern})?`\n    : `/${interceptionPrefix}${pattern}`\n}\n\nfunction getNamedParametrizedRoute(\n  route: string,\n  prefixRouteKeys: boolean,\n  includeSuffix: boolean,\n  includePrefix: boolean,\n  backreferenceDuplicateKeys: boolean\n) {\n  const getSafeRouteKey = buildGetSafeRouteKey()\n  const routeKeys: { [named: string]: string } = {}\n\n  const segments: string[] = []\n  for (const segment of removeTrailingSlash(route).slice(1).split('/')) {\n    const hasInterceptionMarker = INTERCEPTION_ROUTE_MARKERS.some((m) =>\n      segment.startsWith(m)\n    )\n\n    const paramMatches = segment.match(PARAMETER_PATTERN) // Check for parameters\n\n    if (hasInterceptionMarker && paramMatches && paramMatches[2]) {\n      // If there's an interception marker, add it to the segments.\n      segments.push(\n        getSafeKeyFromSegment({\n          getSafeRouteKey,\n          interceptionMarker: paramMatches[1],\n          segment: paramMatches[2],\n          routeKeys,\n          keyPrefix: prefixRouteKeys\n            ? NEXT_INTERCEPTION_MARKER_PREFIX\n            : undefined,\n          backreferenceDuplicateKeys,\n        })\n      )\n    } else if (paramMatches && paramMatches[2]) {\n      // If there's a prefix, add it to the segments if it's enabled.\n      if (includePrefix && paramMatches[1]) {\n        segments.push(`/${escapeStringRegexp(paramMatches[1])}`)\n      }\n\n      let s = getSafeKeyFromSegment({\n        getSafeRouteKey,\n        segment: paramMatches[2],\n        routeKeys,\n        keyPrefix: prefixRouteKeys ? NEXT_QUERY_PARAM_PREFIX : undefined,\n        backreferenceDuplicateKeys,\n      })\n\n      // Remove the leading slash if includePrefix already added it.\n      if (includePrefix && paramMatches[1]) {\n        s = s.substring(1)\n      }\n\n      segments.push(s)\n    } else {\n      segments.push(`/${escapeStringRegexp(segment)}`)\n    }\n\n    // If there's a suffix, add it to the segments if it's enabled.\n    if (includeSuffix && paramMatches && paramMatches[3]) {\n      segments.push(escapeStringRegexp(paramMatches[3]))\n    }\n  }\n\n  return {\n    namedParameterizedRoute: segments.join(''),\n    routeKeys,\n  }\n}\n\n/**\n * This function extends `getRouteRegex` generating also a named regexp where\n * each group is named along with a routeKeys object that indexes the assigned\n * named group with its corresponding key. When the routeKeys need to be\n * prefixed to uniquely identify internally the \"prefixRouteKey\" arg should\n * be \"true\" currently this is only the case when creating the routes-manifest\n * during the build\n */\nexport function getNamedRouteRegex(\n  normalizedRoute: string,\n  options: GetNamedRouteRegexOptions\n) {\n  const result = getNamedParametrizedRoute(\n    normalizedRoute,\n    options.prefixRouteKeys,\n    options.includeSuffix ?? false,\n    options.includePrefix ?? false,\n    options.backreferenceDuplicateKeys ?? false\n  )\n\n  let namedRegex = result.namedParameterizedRoute\n  if (!options.excludeOptionalTrailingSlash) {\n    namedRegex += '(?:/)?'\n  }\n\n  return {\n    ...getRouteRegex(normalizedRoute, options),\n    namedRegex: `^${namedRegex}$`,\n    routeKeys: result.routeKeys,\n  }\n}\n\n/**\n * Generates a named regexp.\n * This is intended to be using for build time only.\n */\nexport function getNamedMiddlewareRegex(\n  normalizedRoute: string,\n  options: {\n    catchAll?: boolean\n  }\n) {\n  const { parameterizedRoute } = getParametrizedRoute(\n    normalizedRoute,\n    false,\n    false\n  )\n  const { catchAll = true } = options\n  if (parameterizedRoute === '/') {\n    let catchAllRegex = catchAll ? '.*' : ''\n    return {\n      namedRegex: `^/${catchAllRegex}$`,\n    }\n  }\n\n  const { namedParameterizedRoute } = getNamedParametrizedRoute(\n    normalizedRoute,\n    false,\n    false,\n    false,\n    false\n  )\n  let catchAllGroupedRegex = catchAll ? '(?:(/.*)?)' : ''\n  return {\n    namedRegex: `^${namedParameterizedRoute}${catchAllGroupedRegex}$`,\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}