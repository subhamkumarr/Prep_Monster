{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n0 && (module.exports = {\n  INTERCEPTION_ROUTE_MARKERS: null,\n  extractInterceptionRouteInformation: null,\n  isInterceptionRouteAppPath: null\n});\nfunction _export(target, all) {\n  for (var name in all) Object.defineProperty(target, name, {\n    enumerable: true,\n    get: all[name]\n  });\n}\n_export(exports, {\n  INTERCEPTION_ROUTE_MARKERS: function () {\n    return INTERCEPTION_ROUTE_MARKERS;\n  },\n  extractInterceptionRouteInformation: function () {\n    return extractInterceptionRouteInformation;\n  },\n  isInterceptionRouteAppPath: function () {\n    return isInterceptionRouteAppPath;\n  }\n});\nconst _apppaths = require(\"./app-paths\");\nconst INTERCEPTION_ROUTE_MARKERS = ['(..)(..)', '(.)', '(..)', '(...)'];\nfunction isInterceptionRouteAppPath(path) {\n  // TODO-APP: add more serious validation\n  return path.split('/').find(segment => INTERCEPTION_ROUTE_MARKERS.find(m => segment.startsWith(m))) !== undefined;\n}\nfunction extractInterceptionRouteInformation(path) {\n  let interceptingRoute, marker, interceptedRoute;\n  for (const segment of path.split('/')) {\n    marker = INTERCEPTION_ROUTE_MARKERS.find(m => segment.startsWith(m));\n    if (marker) {\n      ;\n      [interceptingRoute, interceptedRoute] = path.split(marker, 2);\n      break;\n    }\n  }\n  if (!interceptingRoute || !marker || !interceptedRoute) {\n    throw Object.defineProperty(new Error(\"Invalid interception route: \" + path + \". Must be in the format /<intercepting route>/(..|...|..)(..)/<intercepted route>\"), \"__NEXT_ERROR_CODE\", {\n      value: \"E269\",\n      enumerable: false,\n      configurable: true\n    });\n  }\n  interceptingRoute = (0, _apppaths.normalizeAppPath)(interceptingRoute) // normalize the path, e.g. /(blog)/feed -> /feed\n  ;\n  switch (marker) {\n    case '(.)':\n      // (.) indicates that we should match with sibling routes, so we just need to append the intercepted route to the intercepting route\n      if (interceptingRoute === '/') {\n        interceptedRoute = \"/\" + interceptedRoute;\n      } else {\n        interceptedRoute = interceptingRoute + '/' + interceptedRoute;\n      }\n      break;\n    case '(..)':\n      // (..) indicates that we should match at one level up, so we need to remove the last segment of the intercepting route\n      if (interceptingRoute === '/') {\n        throw Object.defineProperty(new Error(\"Invalid interception route: \" + path + \". Cannot use (..) marker at the root level, use (.) instead.\"), \"__NEXT_ERROR_CODE\", {\n          value: \"E207\",\n          enumerable: false,\n          configurable: true\n        });\n      }\n      interceptedRoute = interceptingRoute.split('/').slice(0, -1).concat(interceptedRoute).join('/');\n      break;\n    case '(...)':\n      // (...) will match the route segment in the root directory, so we need to use the root directory to prepend the intercepted route\n      interceptedRoute = '/' + interceptedRoute;\n      break;\n    case '(..)(..)':\n      // (..)(..) indicates that we should match at two levels up, so we need to remove the last two segments of the intercepting route\n      const splitInterceptingRoute = interceptingRoute.split('/');\n      if (splitInterceptingRoute.length <= 2) {\n        throw Object.defineProperty(new Error(\"Invalid interception route: \" + path + \". Cannot use (..)(..) marker at the root level or one level up.\"), \"__NEXT_ERROR_CODE\", {\n          value: \"E486\",\n          enumerable: false,\n          configurable: true\n        });\n      }\n      interceptedRoute = splitInterceptingRoute.slice(0, -2).concat(interceptedRoute).join('/');\n      break;\n    default:\n      throw Object.defineProperty(new Error('Invariant: unexpected marker'), \"__NEXT_ERROR_CODE\", {\n        value: \"E112\",\n        enumerable: false,\n        configurable: true\n      });\n  }\n  return {\n    interceptingRoute,\n    interceptedRoute\n  };\n}","map":{"version":3,"names":["INTERCEPTION_ROUTE_MARKERS","extractInterceptionRouteInformation","isInterceptionRouteAppPath","path","split","find","segment","m","startsWith","undefined","interceptingRoute","marker","interceptedRoute","Object","defineProperty","Error","_apppaths","normalizeAppPath","slice","concat","join","splitInterceptingRoute","length"],"sources":["C:\\Users\\Subham Kumar\\Desktop\\node_modules\\next\\src\\shared\\lib\\router\\utils\\interception-routes.ts"],"sourcesContent":["import { normalizeAppPath } from './app-paths'\n\n// order matters here, the first match will be used\nexport const INTERCEPTION_ROUTE_MARKERS = [\n  '(..)(..)',\n  '(.)',\n  '(..)',\n  '(...)',\n] as const\n\nexport function isInterceptionRouteAppPath(path: string): boolean {\n  // TODO-APP: add more serious validation\n  return (\n    path\n      .split('/')\n      .find((segment) =>\n        INTERCEPTION_ROUTE_MARKERS.find((m) => segment.startsWith(m))\n      ) !== undefined\n  )\n}\n\nexport function extractInterceptionRouteInformation(path: string) {\n  let interceptingRoute: string | undefined,\n    marker: (typeof INTERCEPTION_ROUTE_MARKERS)[number] | undefined,\n    interceptedRoute: string | undefined\n\n  for (const segment of path.split('/')) {\n    marker = INTERCEPTION_ROUTE_MARKERS.find((m) => segment.startsWith(m))\n    if (marker) {\n      ;[interceptingRoute, interceptedRoute] = path.split(marker, 2)\n      break\n    }\n  }\n\n  if (!interceptingRoute || !marker || !interceptedRoute) {\n    throw new Error(\n      `Invalid interception route: ${path}. Must be in the format /<intercepting route>/(..|...|..)(..)/<intercepted route>`\n    )\n  }\n\n  interceptingRoute = normalizeAppPath(interceptingRoute) // normalize the path, e.g. /(blog)/feed -> /feed\n\n  switch (marker) {\n    case '(.)':\n      // (.) indicates that we should match with sibling routes, so we just need to append the intercepted route to the intercepting route\n      if (interceptingRoute === '/') {\n        interceptedRoute = `/${interceptedRoute}`\n      } else {\n        interceptedRoute = interceptingRoute + '/' + interceptedRoute\n      }\n      break\n    case '(..)':\n      // (..) indicates that we should match at one level up, so we need to remove the last segment of the intercepting route\n      if (interceptingRoute === '/') {\n        throw new Error(\n          `Invalid interception route: ${path}. Cannot use (..) marker at the root level, use (.) instead.`\n        )\n      }\n      interceptedRoute = interceptingRoute\n        .split('/')\n        .slice(0, -1)\n        .concat(interceptedRoute)\n        .join('/')\n      break\n    case '(...)':\n      // (...) will match the route segment in the root directory, so we need to use the root directory to prepend the intercepted route\n      interceptedRoute = '/' + interceptedRoute\n      break\n    case '(..)(..)':\n      // (..)(..) indicates that we should match at two levels up, so we need to remove the last two segments of the intercepting route\n\n      const splitInterceptingRoute = interceptingRoute.split('/')\n      if (splitInterceptingRoute.length <= 2) {\n        throw new Error(\n          `Invalid interception route: ${path}. Cannot use (..)(..) marker at the root level or one level up.`\n        )\n      }\n\n      interceptedRoute = splitInterceptingRoute\n        .slice(0, -2)\n        .concat(interceptedRoute)\n        .join('/')\n      break\n    default:\n      throw new Error('Invariant: unexpected marker')\n  }\n\n  return { interceptingRoute, interceptedRoute }\n}\n"],"mappings":";;;;;;;;;;;;;;;;;EAGaA,0BAA0B,WAAAA,CAAA;WAA1BA,0BAAA;;EAkBGC,mCAAmC,WAAAA,CAAA;WAAnCA,mCAAA;;EAXAC,0BAA0B,WAAAA,CAAA;WAA1BA,0BAAA;;;0BAViB;AAG1B,MAAMF,0BAAA,GAA6B,CACxC,YACA,OACA,QACA,QACD;AAEM,SAASE,2BAA2BC,IAAY;EACrD;EACA,OACEA,IAAA,CACGC,KAAK,CAAC,KACNC,IAAI,CAAEC,OAAA,IACLN,0BAAA,CAA2BK,IAAI,CAAEE,CAAA,IAAMD,OAAA,CAAQE,UAAU,CAACD,CAAA,QACtDE,SAAA;AAEZ;AAEO,SAASR,oCAAoCE,IAAY;EAC9D,IAAIO,iBAAA,EACFC,MAAA,EACAC,gBAAA;EAEF,KAAK,MAAMN,OAAA,IAAWH,IAAA,CAAKC,KAAK,CAAC,MAAM;IACrCO,MAAA,GAASX,0BAAA,CAA2BK,IAAI,CAAEE,CAAA,IAAMD,OAAA,CAAQE,UAAU,CAACD,CAAA;IACnE,IAAII,MAAA,EAAQ;;MACT,CAACD,iBAAA,EAAmBE,gBAAA,CAAiB,GAAGT,IAAA,CAAKC,KAAK,CAACO,MAAA,EAAQ;MAC5D;IACF;EACF;EAEA,IAAI,CAACD,iBAAA,IAAqB,CAACC,MAAA,IAAU,CAACC,gBAAA,EAAkB;IACtD,MAAMC,MAAA,CAAAC,cAEL,CAFK,IAAIC,KAAA,CACR,8BAAC,GAA8BZ,IAAA,GAAK,sFADhC;aAAA;kBAAA;oBAAA;IAEN;EACF;EAEAO,iBAAA,GAAoB,IAAAM,SAAA,CAAAC,gBAAgB,EAACP,iBAAA,EAAmB;EAAA;EAExD,QAAQC,MAAA;IACN,KAAK;MACH;MACA,IAAID,iBAAA,KAAsB,KAAK;QAC7BE,gBAAA,GAAmB,GAAC,GAAGA,gBAAA;MACzB,OAAO;QACLA,gBAAA,GAAmBF,iBAAA,GAAoB,MAAME,gBAAA;MAC/C;MACA;IACF,KAAK;MACH;MACA,IAAIF,iBAAA,KAAsB,KAAK;QAC7B,MAAMG,MAAA,CAAAC,cAEL,CAFK,IAAIC,KAAA,CACR,8BAAC,GAA8BZ,IAAA,GAAK,iEADhC;iBAAA;sBAAA;wBAAA;QAEN;MACF;MACAS,gBAAA,GAAmBF,iBAAA,CAChBN,KAAK,CAAC,KACNc,KAAK,CAAC,GAAG,CAAC,GACVC,MAAM,CAACP,gBAAA,EACPQ,IAAI,CAAC;MACR;IACF,KAAK;MACH;MACAR,gBAAA,GAAmB,MAAMA,gBAAA;MACzB;IACF,KAAK;MACH;MAEA,MAAMS,sBAAA,GAAyBX,iBAAA,CAAkBN,KAAK,CAAC;MACvD,IAAIiB,sBAAA,CAAuBC,MAAM,IAAI,GAAG;QACtC,MAAMT,MAAA,CAAAC,cAEL,CAFK,IAAIC,KAAA,CACR,8BAAC,GAA8BZ,IAAA,GAAK,oEADhC;iBAAA;sBAAA;wBAAA;QAEN;MACF;MAEAS,gBAAA,GAAmBS,sBAAA,CAChBH,KAAK,CAAC,GAAG,CAAC,GACVC,MAAM,CAACP,gBAAA,EACPQ,IAAI,CAAC;MACR;IACF;MACE,MAAMP,MAAA,CAAAC,cAAyC,CAAzC,IAAIC,KAAA,CAAM,iCAAV;eAAA;oBAAA;sBAAA;MAAwC;EAClD;EAEA,OAAO;IAAEL,iBAAA;IAAmBE;EAAiB;AAC/C","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}