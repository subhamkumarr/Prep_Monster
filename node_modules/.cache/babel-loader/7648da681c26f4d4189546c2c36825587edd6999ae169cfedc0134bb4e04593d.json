{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nObject.defineProperty(exports, \"resolveHref\", {\n  enumerable: true,\n  get: function () {\n    return resolveHref;\n  }\n});\nconst _querystring = require(\"../shared/lib/router/utils/querystring\");\nconst _formaturl = require(\"../shared/lib/router/utils/format-url\");\nconst _omit = require(\"../shared/lib/router/utils/omit\");\nconst _utils = require(\"../shared/lib/utils\");\nconst _normalizetrailingslash = require(\"./normalize-trailing-slash\");\nconst _islocalurl = require(\"../shared/lib/router/utils/is-local-url\");\nconst _utils1 = require(\"../shared/lib/router/utils\");\nconst _interpolateas = require(\"../shared/lib/router/utils/interpolate-as\");\nfunction resolveHref(router, href, resolveAs) {\n  // we use a dummy base url for relative urls\n  let base;\n  let urlAsString = typeof href === 'string' ? href : (0, _formaturl.formatWithValidation)(href);\n  // repeated slashes and backslashes in the URL are considered\n  // invalid and will never match a Next.js page/file\n  const urlProtoMatch = urlAsString.match(/^[a-zA-Z]{1,}:\\/\\//);\n  const urlAsStringNoProto = urlProtoMatch ? urlAsString.slice(urlProtoMatch[0].length) : urlAsString;\n  const urlParts = urlAsStringNoProto.split('?', 1);\n  if ((urlParts[0] || '').match(/(\\/\\/|\\\\)/)) {\n    console.error(\"Invalid href '\" + urlAsString + \"' passed to next/router in page: '\" + router.pathname + \"'. Repeated forward-slashes (//) or backslashes \\\\ are not valid in the href.\");\n    const normalizedUrl = (0, _utils.normalizeRepeatedSlashes)(urlAsStringNoProto);\n    urlAsString = (urlProtoMatch ? urlProtoMatch[0] : '') + normalizedUrl;\n  }\n  // Return because it cannot be routed by the Next.js router\n  if (!(0, _islocalurl.isLocalURL)(urlAsString)) {\n    return resolveAs ? [urlAsString] : urlAsString;\n  }\n  try {\n    base = new URL(urlAsString.startsWith('#') ? router.asPath : router.pathname, 'http://n');\n  } catch (_) {\n    // fallback to / for invalid asPath values e.g. //\n    base = new URL('/', 'http://n');\n  }\n  try {\n    const finalUrl = new URL(urlAsString, base);\n    finalUrl.pathname = (0, _normalizetrailingslash.normalizePathTrailingSlash)(finalUrl.pathname);\n    let interpolatedAs = '';\n    if ((0, _utils1.isDynamicRoute)(finalUrl.pathname) && finalUrl.searchParams && resolveAs) {\n      const query = (0, _querystring.searchParamsToUrlQuery)(finalUrl.searchParams);\n      const {\n        result,\n        params\n      } = (0, _interpolateas.interpolateAs)(finalUrl.pathname, finalUrl.pathname, query);\n      if (result) {\n        interpolatedAs = (0, _formaturl.formatWithValidation)({\n          pathname: result,\n          hash: finalUrl.hash,\n          query: (0, _omit.omit)(query, params)\n        });\n      }\n    }\n    // if the origin didn't change, it means we received a relative href\n    const resolvedHref = finalUrl.origin === base.origin ? finalUrl.href.slice(finalUrl.origin.length) : finalUrl.href;\n    return resolveAs ? [resolvedHref, interpolatedAs || resolvedHref] : resolvedHref;\n  } catch (_) {\n    return resolveAs ? [urlAsString] : urlAsString;\n  }\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', {\n    value: true\n  });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}","map":{"version":3,"names":["resolveHref","router","href","resolveAs","base","urlAsString","_formaturl","formatWithValidation","urlProtoMatch","match","urlAsStringNoProto","slice","length","urlParts","split","console","error","pathname","normalizedUrl","_utils","normalizeRepeatedSlashes","_islocalurl","isLocalURL","URL","startsWith","asPath","_","finalUrl","_normalizetrailingslash","normalizePathTrailingSlash","interpolatedAs","_utils1","isDynamicRoute","searchParams","query","_querystring","searchParamsToUrlQuery","result","params","_interpolateas","interpolateAs","hash","_omit","omit","resolvedHref","origin"],"sources":["C:\\Users\\Subham Kumar\\Desktop\\node_modules\\next\\src\\client\\resolve-href.ts"],"sourcesContent":["import type { NextRouter, Url } from '../shared/lib/router/router'\n\nimport { searchParamsToUrlQuery } from '../shared/lib/router/utils/querystring'\nimport { formatWithValidation } from '../shared/lib/router/utils/format-url'\nimport { omit } from '../shared/lib/router/utils/omit'\nimport { normalizeRepeatedSlashes } from '../shared/lib/utils'\nimport { normalizePathTrailingSlash } from './normalize-trailing-slash'\nimport { isLocalURL } from '../shared/lib/router/utils/is-local-url'\nimport { isDynamicRoute } from '../shared/lib/router/utils'\nimport { interpolateAs } from '../shared/lib/router/utils/interpolate-as'\n\n/**\n * Resolves a given hyperlink with a certain router state (basePath not included).\n * Preserves absolute urls.\n */\nexport function resolveHref(\n  router: NextRouter,\n  href: Url,\n  resolveAs: true\n): [string, string] | [string]\nexport function resolveHref(\n  router: NextRouter,\n  href: Url,\n  resolveAs?: false\n): string\nexport function resolveHref(\n  router: NextRouter,\n  href: Url,\n  resolveAs?: boolean\n): [string, string] | [string] | string {\n  // we use a dummy base url for relative urls\n  let base: URL\n  let urlAsString = typeof href === 'string' ? href : formatWithValidation(href)\n\n  // repeated slashes and backslashes in the URL are considered\n  // invalid and will never match a Next.js page/file\n  const urlProtoMatch = urlAsString.match(/^[a-zA-Z]{1,}:\\/\\//)\n  const urlAsStringNoProto = urlProtoMatch\n    ? urlAsString.slice(urlProtoMatch[0].length)\n    : urlAsString\n\n  const urlParts = urlAsStringNoProto.split('?', 1)\n\n  if ((urlParts[0] || '').match(/(\\/\\/|\\\\)/)) {\n    console.error(\n      `Invalid href '${urlAsString}' passed to next/router in page: '${router.pathname}'. Repeated forward-slashes (//) or backslashes \\\\ are not valid in the href.`\n    )\n    const normalizedUrl = normalizeRepeatedSlashes(urlAsStringNoProto)\n    urlAsString = (urlProtoMatch ? urlProtoMatch[0] : '') + normalizedUrl\n  }\n\n  // Return because it cannot be routed by the Next.js router\n  if (!isLocalURL(urlAsString)) {\n    return (resolveAs ? [urlAsString] : urlAsString) as string\n  }\n\n  try {\n    base = new URL(\n      urlAsString.startsWith('#') ? router.asPath : router.pathname,\n      'http://n'\n    )\n  } catch (_) {\n    // fallback to / for invalid asPath values e.g. //\n    base = new URL('/', 'http://n')\n  }\n\n  try {\n    const finalUrl = new URL(urlAsString, base)\n    finalUrl.pathname = normalizePathTrailingSlash(finalUrl.pathname)\n    let interpolatedAs = ''\n\n    if (\n      isDynamicRoute(finalUrl.pathname) &&\n      finalUrl.searchParams &&\n      resolveAs\n    ) {\n      const query = searchParamsToUrlQuery(finalUrl.searchParams)\n\n      const { result, params } = interpolateAs(\n        finalUrl.pathname,\n        finalUrl.pathname,\n        query\n      )\n\n      if (result) {\n        interpolatedAs = formatWithValidation({\n          pathname: result,\n          hash: finalUrl.hash,\n          query: omit(query, params),\n        })\n      }\n    }\n\n    // if the origin didn't change, it means we received a relative href\n    const resolvedHref =\n      finalUrl.origin === base.origin\n        ? finalUrl.href.slice(finalUrl.origin.length)\n        : finalUrl.href\n\n    return resolveAs\n      ? [resolvedHref, interpolatedAs || resolvedHref]\n      : resolvedHref\n  } catch (_) {\n    return resolveAs ? [urlAsString] : urlAsString\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}