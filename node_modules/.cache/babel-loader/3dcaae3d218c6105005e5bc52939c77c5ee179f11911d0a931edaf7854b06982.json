{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nObject.defineProperty(exports, \"interpolateAs\", {\n  enumerable: true,\n  get: function () {\n    return interpolateAs;\n  }\n});\nconst _routematcher = require(\"./route-matcher\");\nconst _routeregex = require(\"./route-regex\");\nfunction interpolateAs(route, asPathname, query) {\n  let interpolatedRoute = '';\n  const dynamicRegex = (0, _routeregex.getRouteRegex)(route);\n  const dynamicGroups = dynamicRegex.groups;\n  const dynamicMatches =\n  // Try to match the dynamic route against the asPath\n  (asPathname !== route ? (0, _routematcher.getRouteMatcher)(dynamicRegex)(asPathname) : '') ||\n  // Fall back to reading the values from the href\n  // TODO: should this take priority; also need to change in the router.\n  query;\n  interpolatedRoute = route;\n  const params = Object.keys(dynamicGroups);\n  if (!params.every(param => {\n    let value = dynamicMatches[param] || '';\n    const {\n      repeat,\n      optional\n    } = dynamicGroups[param];\n    // support single-level catch-all\n    // TODO: more robust handling for user-error (passing `/`)\n    let replaced = \"[\" + (repeat ? '...' : '') + param + \"]\";\n    if (optional) {\n      replaced = (!value ? '/' : '') + \"[\" + replaced + \"]\";\n    }\n    if (repeat && !Array.isArray(value)) value = [value];\n    return (optional || param in dynamicMatches) && (\n    // Interpolate group into data URL if present\n    interpolatedRoute = interpolatedRoute.replace(replaced, repeat ? value.map(\n    // these values should be fully encoded instead of just\n    // path delimiter escaped since they are being inserted\n    // into the URL and we expect URL encoded segments\n    // when parsing dynamic route params\n    segment => encodeURIComponent(segment)).join('/') : encodeURIComponent(value)) || '/');\n  })) {\n    interpolatedRoute = '' // did not satisfy all requirements\n    ;\n    // n.b. We ignore this error because we handle warning for this case in\n    // development in the `<Link>` component directly.\n  }\n  return {\n    params,\n    result: interpolatedRoute\n  };\n}","map":{"version":3,"names":["interpolateAs","route","asPathname","query","interpolatedRoute","dynamicRegex","_routeregex","getRouteRegex","dynamicGroups","groups","dynamicMatches","_routematcher","getRouteMatcher","params","Object","keys","every","param","value","repeat","optional","replaced","Array","isArray","replace","map","segment","encodeURIComponent","join","result"],"sources":["C:\\Users\\Subham Kumar\\Desktop\\node_modules\\next\\src\\shared\\lib\\router\\utils\\interpolate-as.ts"],"sourcesContent":["import type { ParsedUrlQuery } from 'querystring'\n\nimport { getRouteMatcher } from './route-matcher'\nimport { getRouteRegex } from './route-regex'\n\nexport function interpolateAs(\n  route: string,\n  asPathname: string,\n  query: ParsedUrlQuery\n) {\n  let interpolatedRoute = ''\n\n  const dynamicRegex = getRouteRegex(route)\n  const dynamicGroups = dynamicRegex.groups\n  const dynamicMatches =\n    // Try to match the dynamic route against the asPath\n    (asPathname !== route ? getRouteMatcher(dynamicRegex)(asPathname) : '') ||\n    // Fall back to reading the values from the href\n    // TODO: should this take priority; also need to change in the router.\n    query\n\n  interpolatedRoute = route\n  const params = Object.keys(dynamicGroups)\n\n  if (\n    !params.every((param) => {\n      let value = dynamicMatches[param] || ''\n      const { repeat, optional } = dynamicGroups[param]\n\n      // support single-level catch-all\n      // TODO: more robust handling for user-error (passing `/`)\n      let replaced = `[${repeat ? '...' : ''}${param}]`\n      if (optional) {\n        replaced = `${!value ? '/' : ''}[${replaced}]`\n      }\n      if (repeat && !Array.isArray(value)) value = [value]\n\n      return (\n        (optional || param in dynamicMatches) &&\n        // Interpolate group into data URL if present\n        (interpolatedRoute =\n          interpolatedRoute!.replace(\n            replaced,\n            repeat\n              ? (value as string[])\n                  .map(\n                    // these values should be fully encoded instead of just\n                    // path delimiter escaped since they are being inserted\n                    // into the URL and we expect URL encoded segments\n                    // when parsing dynamic route params\n                    (segment) => encodeURIComponent(segment)\n                  )\n                  .join('/')\n              : encodeURIComponent(value as string)\n          ) || '/')\n      )\n    })\n  ) {\n    interpolatedRoute = '' // did not satisfy all requirements\n\n    // n.b. We ignore this error because we handle warning for this case in\n    // development in the `<Link>` component directly.\n  }\n  return {\n    params,\n    result: interpolatedRoute,\n  }\n}\n"],"mappings":";;;;;+BAKgB;;;WAAAA,aAAA;;;8BAHgB;4BACF;AAEvB,SAASA,cACdC,KAAa,EACbC,UAAkB,EAClBC,KAAqB;EAErB,IAAIC,iBAAA,GAAoB;EAExB,MAAMC,YAAA,GAAe,IAAAC,WAAA,CAAAC,aAAa,EAACN,KAAA;EACnC,MAAMO,aAAA,GAAgBH,YAAA,CAAaI,MAAM;EACzC,MAAMC,cAAA;EAEJ;EAAC,CAAAR,UAAA,KAAeD,KAAA,GAAQ,IAAAU,aAAA,CAAAC,eAAe,EAACP,YAAA,EAAcH,UAAA,IAAc,EAAC;EACrE;EACA;EACAC,KAAA;EAEFC,iBAAA,GAAoBH,KAAA;EACpB,MAAMY,MAAA,GAASC,MAAA,CAAOC,IAAI,CAACP,aAAA;EAE3B,IACE,CAACK,MAAA,CAAOG,KAAK,CAAEC,KAAA;IACb,IAAIC,KAAA,GAAQR,cAAc,CAACO,KAAA,CAAM,IAAI;IACrC,MAAM;MAAEE,MAAM;MAAEC;IAAQ,CAAE,GAAGZ,aAAa,CAACS,KAAA,CAAM;IAEjD;IACA;IACA,IAAII,QAAA,GAAW,GAAC,IAAGF,MAAA,GAAS,QAAQ,EAAC,IAAIF,KAAA,GAAM;IAC/C,IAAIG,QAAA,EAAU;MACZC,QAAA,GAAW,CAAG,CAACH,KAAA,GAAQ,MAAM,EAAC,IAAE,MAAGG,QAAA,GAAS;IAC9C;IACA,IAAIF,MAAA,IAAU,CAACG,KAAA,CAAMC,OAAO,CAACL,KAAA,GAAQA,KAAA,GAAQ,CAACA,KAAA,CAAM;IAEpD,OACE,CAACE,QAAA,IAAYH,KAAA,IAASP,cAAa;IACnC;IACCN,iBAAA,GACCA,iBAAA,CAAmBoB,OAAO,CACxBH,QAAA,EACAF,MAAA,GACID,KAAC,CACEO,GAAG;IACF;IACA;IACA;IACA;IACCC,OAAA,IAAYC,kBAAA,CAAmBD,OAAA,GAEjCE,IAAI,CAAC,OACRD,kBAAA,CAAmBT,KAAA,MACpB,GAAE;EAEb,IACA;IACAd,iBAAA,GAAoB,GAAG;IAAA;IAEvB;IACA;EACF;EACA,OAAO;IACLS,MAAA;IACAgB,MAAA,EAAQzB;EACV;AACF","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}