{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nObject.defineProperty(exports, \"getRouteMatcher\", {\n  enumerable: true,\n  get: function () {\n    return getRouteMatcher;\n  }\n});\nconst _utils = require(\"../../utils\");\nfunction getRouteMatcher(param) {\n  let {\n    re,\n    groups\n  } = param;\n  return pathname => {\n    const routeMatch = re.exec(pathname);\n    if (!routeMatch) return false;\n    const decode = param => {\n      try {\n        return decodeURIComponent(param);\n      } catch (e) {\n        throw Object.defineProperty(new _utils.DecodeError('failed to decode param'), \"__NEXT_ERROR_CODE\", {\n          value: \"E528\",\n          enumerable: false,\n          configurable: true\n        });\n      }\n    };\n    const params = {};\n    for (const [key, group] of Object.entries(groups)) {\n      const match = routeMatch[group.pos];\n      if (match !== undefined) {\n        if (group.repeat) {\n          params[key] = match.split('/').map(entry => decode(entry));\n        } else {\n          params[key] = decode(match);\n        }\n      }\n    }\n    return params;\n  };\n}","map":{"version":3,"names":["getRouteMatcher","param","re","groups","pathname","routeMatch","exec","decode","decodeURIComponent","e","Object","defineProperty","_utils","DecodeError","params","key","group","entries","match","pos","undefined","repeat","split","map","entry"],"sources":["C:\\Users\\Subham Kumar\\Desktop\\node_modules\\next\\src\\shared\\lib\\router\\utils\\route-matcher.ts"],"sourcesContent":["import type { Group } from './route-regex'\nimport { DecodeError } from '../../utils'\nimport type { Params } from '../../../../server/request/params'\n\nexport interface RouteMatchFn {\n  (pathname: string): false | Params\n}\n\ntype RouteMatcherOptions = {\n  // We only use the exec method of the RegExp object. This helps us avoid using\n  // type assertions that the passed in properties are of the correct type.\n  re: Pick<RegExp, 'exec'>\n  groups: Record<string, Group>\n}\n\nexport function getRouteMatcher({\n  re,\n  groups,\n}: RouteMatcherOptions): RouteMatchFn {\n  return (pathname: string) => {\n    const routeMatch = re.exec(pathname)\n    if (!routeMatch) return false\n\n    const decode = (param: string) => {\n      try {\n        return decodeURIComponent(param)\n      } catch {\n        throw new DecodeError('failed to decode param')\n      }\n    }\n\n    const params: Params = {}\n    for (const [key, group] of Object.entries(groups)) {\n      const match = routeMatch[group.pos]\n      if (match !== undefined) {\n        if (group.repeat) {\n          params[key] = match.split('/').map((entry) => decode(entry))\n        } else {\n          params[key] = decode(match)\n        }\n      }\n    }\n\n    return params\n  }\n}\n"],"mappings":";;;;;+BAegB;;;WAAAA,eAAA;;;uBAdY;AAcrB,SAASA,gBAAgBC,KAGV;EAHU;IAC9BC,EAAE;IACFC;EAAM,CACc,GAHUF,KAAA;EAI9B,OAAQG,QAAA;IACN,MAAMC,UAAA,GAAaH,EAAA,CAAGI,IAAI,CAACF,QAAA;IAC3B,IAAI,CAACC,UAAA,EAAY,OAAO;IAExB,MAAME,MAAA,GAAUN,KAAA;MACd,IAAI;QACF,OAAOO,kBAAA,CAAmBP,KAAA;MAC5B,EAAE,OAAAQ,CAAA,EAAM;QACN,MAAMC,MAAA,CAAAC,cAAyC,CAAzC,IAAIC,MAAA,CAAAC,WAAW,CAAC,2BAAhB;iBAAA;sBAAA;wBAAA;QAAwC;MAChD;IACF;IAEA,MAAMC,MAAA,GAAiB,CAAC;IACxB,KAAK,MAAM,CAACC,GAAA,EAAKC,KAAA,CAAM,IAAIN,MAAA,CAAOO,OAAO,CAACd,MAAA,GAAS;MACjD,MAAMe,KAAA,GAAQb,UAAU,CAACW,KAAA,CAAMG,GAAG,CAAC;MACnC,IAAID,KAAA,KAAUE,SAAA,EAAW;QACvB,IAAIJ,KAAA,CAAMK,MAAM,EAAE;UAChBP,MAAM,CAACC,GAAA,CAAI,GAAGG,KAAA,CAAMI,KAAK,CAAC,KAAKC,GAAG,CAAEC,KAAA,IAAUjB,MAAA,CAAOiB,KAAA;QACvD,OAAO;UACLV,MAAM,CAACC,GAAA,CAAI,GAAGR,MAAA,CAAOW,KAAA;QACvB;MACF;IACF;IAEA,OAAOJ,MAAA;EACT;AACF","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}