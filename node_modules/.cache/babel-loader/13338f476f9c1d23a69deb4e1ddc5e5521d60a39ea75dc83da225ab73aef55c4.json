{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nObject.defineProperty(exports, \"useMergedRef\", {\n  enumerable: true,\n  get: function () {\n    return useMergedRef;\n  }\n});\nconst _react = require(\"react\");\nfunction useMergedRef(refA, refB) {\n  const cleanupA = (0, _react.useRef)(null);\n  const cleanupB = (0, _react.useRef)(null);\n  // NOTE: In theory, we could skip the wrapping if only one of the refs is non-null.\n  // (this happens often if the user doesn't pass a ref to Link/Form/Image)\n  // But this can cause us to leak a cleanup-ref into user code (e.g. via `<Link legacyBehavior>`),\n  // and the user might pass that ref into ref-merging library that doesn't support cleanup refs\n  // (because it hasn't been updated for React 19)\n  // which can then cause things to blow up, because a cleanup-returning ref gets called with `null`.\n  // So in practice, it's safer to be defensive and always wrap the ref, even on React 19.\n  return (0, _react.useCallback)(current => {\n    if (current === null) {\n      const cleanupFnA = cleanupA.current;\n      if (cleanupFnA) {\n        cleanupA.current = null;\n        cleanupFnA();\n      }\n      const cleanupFnB = cleanupB.current;\n      if (cleanupFnB) {\n        cleanupB.current = null;\n        cleanupFnB();\n      }\n    } else {\n      if (refA) {\n        cleanupA.current = applyRef(refA, current);\n      }\n      if (refB) {\n        cleanupB.current = applyRef(refB, current);\n      }\n    }\n  }, [refA, refB]);\n}\nfunction applyRef(refA, current) {\n  if (typeof refA === 'function') {\n    const cleanup = refA(current);\n    if (typeof cleanup === 'function') {\n      return cleanup;\n    } else {\n      return () => refA(null);\n    }\n  } else {\n    refA.current = current;\n    return () => {\n      refA.current = null;\n    };\n  }\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', {\n    value: true\n  });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}","map":{"version":3,"names":["useMergedRef","refA","refB","cleanupA","_react","useRef","cleanupB","useCallback","current","cleanupFnA","cleanupFnB","applyRef","cleanup"],"sources":["C:\\Users\\Subham Kumar\\Desktop\\node_modules\\next\\src\\client\\use-merged-ref.ts"],"sourcesContent":["import { useCallback, useRef, type Ref } from 'react'\n\n// This is a compatibility hook to support React 18 and 19 refs.\n// In 19, a cleanup function from refs may be returned.\n// In 18, returning a cleanup function creates a warning.\n// Since we take userspace refs, we don't know ahead of time if a cleanup function will be returned.\n// This implements cleanup functions with the old behavior in 18.\n// We know refs are always called alternating with `null` and then `T`.\n// So a call with `null` means we need to call the previous cleanup functions.\nexport function useMergedRef<TElement>(\n  refA: Ref<TElement>,\n  refB: Ref<TElement>\n): Ref<TElement> {\n  const cleanupA = useRef<(() => void) | null>(null)\n  const cleanupB = useRef<(() => void) | null>(null)\n\n  // NOTE: In theory, we could skip the wrapping if only one of the refs is non-null.\n  // (this happens often if the user doesn't pass a ref to Link/Form/Image)\n  // But this can cause us to leak a cleanup-ref into user code (e.g. via `<Link legacyBehavior>`),\n  // and the user might pass that ref into ref-merging library that doesn't support cleanup refs\n  // (because it hasn't been updated for React 19)\n  // which can then cause things to blow up, because a cleanup-returning ref gets called with `null`.\n  // So in practice, it's safer to be defensive and always wrap the ref, even on React 19.\n  return useCallback(\n    (current: TElement | null): void => {\n      if (current === null) {\n        const cleanupFnA = cleanupA.current\n        if (cleanupFnA) {\n          cleanupA.current = null\n          cleanupFnA()\n        }\n        const cleanupFnB = cleanupB.current\n        if (cleanupFnB) {\n          cleanupB.current = null\n          cleanupFnB()\n        }\n      } else {\n        if (refA) {\n          cleanupA.current = applyRef(refA, current)\n        }\n        if (refB) {\n          cleanupB.current = applyRef(refB, current)\n        }\n      }\n    },\n    [refA, refB]\n  )\n}\n\nfunction applyRef<TElement>(\n  refA: NonNullable<Ref<TElement>>,\n  current: TElement\n) {\n  if (typeof refA === 'function') {\n    const cleanup = refA(current)\n    if (typeof cleanup === 'function') {\n      return cleanup\n    } else {\n      return () => refA(null)\n    }\n  } else {\n    refA.current = current\n    return () => {\n      refA.current = null\n    }\n  }\n}\n"],"mappings":";;;;;+BASgB;;;WAAAA,YAAA;;;uBAT8B;AASvC,SAASA,aACdC,IAAmB,EACnBC,IAAmB;EAEnB,MAAMC,QAAA,GAAW,IAAAC,MAAA,CAAAC,MAAM,EAAsB;EAC7C,MAAMC,QAAA,GAAW,IAAAF,MAAA,CAAAC,MAAM,EAAsB;EAE7C;EACA;EACA;EACA;EACA;EACA;EACA;EACA,OAAO,IAAAD,MAAA,CAAAG,WAAW,EACfC,OAAA;IACC,IAAIA,OAAA,KAAY,MAAM;MACpB,MAAMC,UAAA,GAAaN,QAAA,CAASK,OAAO;MACnC,IAAIC,UAAA,EAAY;QACdN,QAAA,CAASK,OAAO,GAAG;QACnBC,UAAA;MACF;MACA,MAAMC,UAAA,GAAaJ,QAAA,CAASE,OAAO;MACnC,IAAIE,UAAA,EAAY;QACdJ,QAAA,CAASE,OAAO,GAAG;QACnBE,UAAA;MACF;IACF,OAAO;MACL,IAAIT,IAAA,EAAM;QACRE,QAAA,CAASK,OAAO,GAAGG,QAAA,CAASV,IAAA,EAAMO,OAAA;MACpC;MACA,IAAIN,IAAA,EAAM;QACRI,QAAA,CAASE,OAAO,GAAGG,QAAA,CAAST,IAAA,EAAMM,OAAA;MACpC;IACF;EACF,GACA,CAACP,IAAA,EAAMC,IAAA,CAAK;AAEhB;AAEA,SAASS,SACPV,IAAgC,EAChCO,OAAiB;EAEjB,IAAI,OAAOP,IAAA,KAAS,YAAY;IAC9B,MAAMW,OAAA,GAAUX,IAAA,CAAKO,OAAA;IACrB,IAAI,OAAOI,OAAA,KAAY,YAAY;MACjC,OAAOA,OAAA;IACT,OAAO;MACL,OAAO,MAAMX,IAAA,CAAK;IACpB;EACF,OAAO;IACLA,IAAA,CAAKO,OAAO,GAAGA,OAAA;IACf,OAAO;MACLP,IAAA,CAAKO,OAAO,GAAG;IACjB;EACF;AACF","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}