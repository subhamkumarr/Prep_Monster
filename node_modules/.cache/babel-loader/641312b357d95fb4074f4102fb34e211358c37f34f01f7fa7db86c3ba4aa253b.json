{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nObject.defineProperty(exports, \"normalizeLocalePath\", {\n  enumerable: true,\n  get: function () {\n    return normalizeLocalePath;\n  }\n});\n/**\n * A cache of lowercased locales for each list of locales. This is stored as a\n * WeakMap so if the locales are garbage collected, the cache entry will be\n * removed as well.\n */\nconst cache = new WeakMap();\nfunction normalizeLocalePath(pathname, locales) {\n  // If locales is undefined, return the pathname as is.\n  if (!locales) return {\n    pathname\n  };\n  // Get the cached lowercased locales or create a new cache entry.\n  let lowercasedLocales = cache.get(locales);\n  if (!lowercasedLocales) {\n    lowercasedLocales = locales.map(locale => locale.toLowerCase());\n    cache.set(locales, lowercasedLocales);\n  }\n  let detectedLocale;\n  // The first segment will be empty, because it has a leading `/`. If\n  // there is no further segment, there is no locale (or it's the default).\n  const segments = pathname.split('/', 2);\n  // If there's no second segment (ie, the pathname is just `/`), there's no\n  // locale.\n  if (!segments[1]) return {\n    pathname\n  };\n  // The second segment will contain the locale part if any.\n  const segment = segments[1].toLowerCase();\n  // See if the segment matches one of the locales. If it doesn't, there is\n  // no locale (or it's the default).\n  const index = lowercasedLocales.indexOf(segment);\n  if (index < 0) return {\n    pathname\n  };\n  // Return the case-sensitive locale.\n  detectedLocale = locales[index];\n  // Remove the `/${locale}` part of the pathname.\n  pathname = pathname.slice(detectedLocale.length + 1) || '/';\n  return {\n    pathname,\n    detectedLocale\n  };\n}","map":{"version":3,"names":["normalizeLocalePath","cache","WeakMap","pathname","locales","lowercasedLocales","get","map","locale","toLowerCase","set","detectedLocale","segments","split","segment","index","indexOf","slice","length"],"sources":["C:\\Users\\Subham Kumar\\Desktop\\node_modules\\next\\src\\shared\\lib\\i18n\\normalize-locale-path.ts"],"sourcesContent":["export interface PathLocale {\n  detectedLocale?: string\n  pathname: string\n}\n\n/**\n * A cache of lowercased locales for each list of locales. This is stored as a\n * WeakMap so if the locales are garbage collected, the cache entry will be\n * removed as well.\n */\nconst cache = new WeakMap<readonly string[], readonly string[]>()\n\n/**\n * For a pathname that may include a locale from a list of locales, it\n * removes the locale from the pathname returning it alongside with the\n * detected locale.\n *\n * @param pathname A pathname that may include a locale.\n * @param locales A list of locales.\n * @returns The detected locale and pathname without locale\n */\nexport function normalizeLocalePath(\n  pathname: string,\n  locales?: readonly string[]\n): PathLocale {\n  // If locales is undefined, return the pathname as is.\n  if (!locales) return { pathname }\n\n  // Get the cached lowercased locales or create a new cache entry.\n  let lowercasedLocales = cache.get(locales)\n  if (!lowercasedLocales) {\n    lowercasedLocales = locales.map((locale) => locale.toLowerCase())\n    cache.set(locales, lowercasedLocales)\n  }\n\n  let detectedLocale: string | undefined\n\n  // The first segment will be empty, because it has a leading `/`. If\n  // there is no further segment, there is no locale (or it's the default).\n  const segments = pathname.split('/', 2)\n\n  // If there's no second segment (ie, the pathname is just `/`), there's no\n  // locale.\n  if (!segments[1]) return { pathname }\n\n  // The second segment will contain the locale part if any.\n  const segment = segments[1].toLowerCase()\n\n  // See if the segment matches one of the locales. If it doesn't, there is\n  // no locale (or it's the default).\n  const index = lowercasedLocales.indexOf(segment)\n  if (index < 0) return { pathname }\n\n  // Return the case-sensitive locale.\n  detectedLocale = locales[index]\n\n  // Remove the `/${locale}` part of the pathname.\n  pathname = pathname.slice(detectedLocale.length + 1) || '/'\n\n  return { pathname, detectedLocale }\n}\n"],"mappings":";;;;;+BAqBgB;;;WAAAA,mBAAA;;;AAhBhB;;;;;AAKA,MAAMC,KAAA,GAAQ,IAAIC,OAAA;AAWX,SAASF,oBACdG,QAAgB,EAChBC,OAA2B;EAE3B;EACA,IAAI,CAACA,OAAA,EAAS,OAAO;IAAED;EAAS;EAEhC;EACA,IAAIE,iBAAA,GAAoBJ,KAAA,CAAMK,GAAG,CAACF,OAAA;EAClC,IAAI,CAACC,iBAAA,EAAmB;IACtBA,iBAAA,GAAoBD,OAAA,CAAQG,GAAG,CAAEC,MAAA,IAAWA,MAAA,CAAOC,WAAW;IAC9DR,KAAA,CAAMS,GAAG,CAACN,OAAA,EAASC,iBAAA;EACrB;EAEA,IAAIM,cAAA;EAEJ;EACA;EACA,MAAMC,QAAA,GAAWT,QAAA,CAASU,KAAK,CAAC,KAAK;EAErC;EACA;EACA,IAAI,CAACD,QAAQ,CAAC,EAAE,EAAE,OAAO;IAAET;EAAS;EAEpC;EACA,MAAMW,OAAA,GAAUF,QAAQ,CAAC,EAAE,CAACH,WAAW;EAEvC;EACA;EACA,MAAMM,KAAA,GAAQV,iBAAA,CAAkBW,OAAO,CAACF,OAAA;EACxC,IAAIC,KAAA,GAAQ,GAAG,OAAO;IAAEZ;EAAS;EAEjC;EACAQ,cAAA,GAAiBP,OAAO,CAACW,KAAA,CAAM;EAE/B;EACAZ,QAAA,GAAWA,QAAA,CAASc,KAAK,CAACN,cAAA,CAAeO,MAAM,GAAG,MAAM;EAExD,OAAO;IAAEf,QAAA;IAAUQ;EAAe;AACpC","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}